-- Tablas base
CREATE TABLE public.empresas (
  id_empresa SERIAL PRIMARY KEY,
  nombre character varying NOT NULL,
  plan_actual character varying,
  fecha_inicio timestamp without time zone DEFAULT now(),
  fecha_fin timestamp without time zone,
  estado character varying DEFAULT 'activa'
);

CREATE TABLE public.roles (
  id_rol SERIAL PRIMARY KEY,
  name character varying NOT NULL UNIQUE
);

CREATE TABLE public.permissions (
  id_permission SERIAL PRIMARY KEY,
  key character varying NOT NULL UNIQUE,
  description text NOT NULL
);

-- Usuarios (depende de roles y empresas)
CREATE TABLE public.usuarios (
  id_usuario SERIAL PRIMARY KEY,
  nombre character varying NOT NULL,
  email character varying NOT NULL UNIQUE,
  cedula varchar(20) UNIQUE,
  apellido varchar(20),
  username varchar(20) UNIQUE,
  password_hash text NOT NULL,
  id_roles integer,
  id_empresa integer,
  creado_en timestamp without time zone DEFAULT now(),
  estado_activo boolean default true,
  CONSTRAINT usuarios_rol_id_fkey FOREIGN KEY (id_roles) REFERENCES public.roles(id_rol),
  CONSTRAINT usuarios_empresa_id_fkey FOREIGN KEY (id_empresa) REFERENCES public.empresas(id_empresa)
);

-- Propietarios (depende de usuarios)
CREATE TABLE public.propietarios (
  id_propietario SERIAL PRIMARY KEY,
  id_usuario integer UNIQUE,
  telefono character varying,
  direccion text,
  CONSTRAINT propietarios_usuario_id_fkey FOREIGN KEY (id_usuario) REFERENCES public.usuarios(id_usuario)
);

-- Inmuebles (depende de empresas y propietarios)
CREATE TABLE public.inmuebles (
  id_inmueble SERIAL PRIMARY KEY,
  nombre character varying,
  descripcion text,
  direccion text,
  capacidad integer,
  id_propietario integer,
  id_empresa integer,
  estado character varying DEFAULT 'activo',
  CONSTRAINT inmuebles_propietario_id_fkey FOREIGN KEY (id_propietario) REFERENCES public.propietarios(id_propietario),
  CONSTRAINT inmuebles_empresa_id_fkey FOREIGN KEY (id_empresa) REFERENCES public.empresas(id_empresa)
);

-- Reservas (depende de inmuebles)
CREATE TABLE public.reservas (
  id_reserva SERIAL PRIMARY KEY,
  id_inmueble integer,
  fecha_inicio date NOT NULL,
  fecha_fin date NOT NULL,
  estado character varying,
  created_at timestamp without time zone DEFAULT now(),
  CONSTRAINT reservas_inmueble_id_fkey FOREIGN KEY (id_inmueble) REFERENCES public.inmuebles(id_inmueble)
);

-- Huespedes
CREATE TABLE public.huespedes (
  id_huesped SERIAL PRIMARY KEY,
  nombre character varying,
  documento_identidad character varying,
  telefono character varying,
  correo character varying
);

-- Huespedes_Reservas (depende de reservas y huespedes)
CREATE TABLE public.huespedes_reservas (
  id_reserva integer NOT NULL,
  id_huesped integer NOT NULL,
  es_principal boolean DEFAULT false,
  CONSTRAINT huespedes_reservas_pkey PRIMARY KEY (id_reserva, id_huesped),
  CONSTRAINT huespedes_reservas_reserva_id_fkey FOREIGN KEY (id_reserva) REFERENCES public.reservas(id_reserva),
  CONSTRAINT huespedes_reservas_huesped_id_fkey FOREIGN KEY (id_huesped) REFERENCES public.huespedes(id_huesped)
);

-- Ingresos y Egresos (depende de reservas e inmuebles)
CREATE TABLE public.ingresos (
  id_ingreso SERIAL PRIMARY KEY,
  id_inmueble integer,
  id_reserva integer,
  monto numeric,
  descripcion text,
  fecha date NOT NULL,
  CONSTRAINT ingresos_inmueble_id_fkey FOREIGN KEY (id_inmueble) REFERENCES public.inmuebles(id_inmueble),
  CONSTRAINT ingresos_reserva_id_fkey FOREIGN KEY (id_reserva) REFERENCES public.reservas(id_reserva)
);

CREATE TABLE public.egresos (
  id_egreso SERIAL PRIMARY KEY,
  id_inmueble integer,
  monto numeric,
  descripcion text,
  categoria character varying,
  fecha date NOT NULL,
  CONSTRAINT egresos_inmueble_id_fkey FOREIGN KEY (id_inmueble) REFERENCES public.inmuebles(id_inmueble)
);

-- Administradores de inmuebles
CREATE TABLE public.administradores_inmuebles (
  id_usuario integer NOT NULL,
  id_inmueble integer NOT NULL,
  CONSTRAINT administradores_inmuebles_pkey PRIMARY KEY (id_usuario, id_inmueble),
  CONSTRAINT administradores_inmuebles_usuario_id_fkey FOREIGN KEY (id_usuario) REFERENCES public.usuarios(id_usuario),
  CONSTRAINT administradores_inmuebles_inmueble_id_fkey FOREIGN KEY (id_inmueble) REFERENCES public.inmuebles(id_inmueble)
);

-- Roles - Permissions (tabla pivote)
CREATE TABLE public.roles_permissions (
  id_rol integer NOT NULL,
  id_permission integer NOT NULL,
  CONSTRAINT roles_permissions_pkey PRIMARY KEY (id_rol, id_permission),
  CONSTRAINT roles_permissions_role_id_fkey FOREIGN KEY (id_rol) REFERENCES public.roles(id_rol),
  CONSTRAINT roles_permissions_permission_id_fkey FOREIGN KEY (id_permission) REFERENCES public.permissions(id_permission)
);



insert into roles (name) values ('superadmin'), ('empresa'),('administrador'),('propietario');
-- Usuario administrador independiente
INSERT INTO usuarios (nombre, email, password_hash, id_roles, id_empresa)
VALUES ('Carlos Torres', 'carlos@adminind.com', 'hashed_pw_1', 3, NULL);

-- Crear empresa 1
INSERT INTO empresas (nombre, plan_actual)
VALUES ('Waiwahost', 'Full');

-- Propietarios (dueños de los inmuebles)
INSERT INTO usuarios (nombre, email, password_hash, id_roles)
VALUES 
  ('Ana Propietaria', 'ana@prop.com', 'hashed_pw_2', 4),
  ('Luis Dueño', 'luis@prop.com', 'hashed_pw_3', 4);

-- Registros en tabla propietarios
INSERT INTO propietarios (id_usuario, telefono)
VALUES 
  (2, '3001230001'),
  (3, '3001230002');
-- Inmuebles administrados por Carlos, pero con distintos propietarios
INSERT INTO inmuebles (nombre, direccion, id_propietario, id_empresa)
VALUES 
  ('Apartamento Ana', 'Calle 1 #123', 1, NULL),
  ('Casa Luis', 'Carrera 5 #456', 2, NULL);

-- Relación de Carlos como administrador de ambos inmuebles
INSERT INTO administradores_inmuebles (id_usuario, id_inmueble)
VALUES 
  (1, 3),
  (1, 4);

-- Usuario administrador independiente
INSERT INTO usuarios (nombre, email, password_hash, id_roles, id_empresa)
VALUES ('superadmin', 'admin@mail.com', 'hashed_pw_1', 1, NULL);

INSERT INTO permissions (key, description) VALUES
('ver_dashboard', 'Ver panel principal'),
('ver_inmuebles', 'Ver lista de inmuebles'),
('crear_inmueble', 'Crear un nuevo inmueble'),
('editar_inmueble', 'Editar inmuebles'),
('eliminar_inmueble', 'Eliminar inmuebles'),
('ver_reservas', 'Ver reservas'),
('crear_reserva', 'Crear nueva reserva'),
('editar_reserva', 'Editar reservas'),
('eliminar_reserva', 'Eliminar reservas'),
('ver_reportes', 'Ver reportes financieros'),
('ver_usuarios', 'Ver y gestionar usuarios'),
('ver_caja', 'Ver caja e ingresos/egresos'),
('ver_propietarios', 'Ver información de propietarios');

INSERT INTO permissions (key, description) VALUES
('ver_disponibilidad', 'Ver disponibilidad'),
('ver_huespedes', 'Ver huespedes');

INSERT INTO public.permissions (key, description)
VALUES ('ver_egresos','Ver egresos'),
('ver_ingresos','Ver ingresos'),
('eliminar_usuarios','Eliminar usuarios'),
('crear_usuarios','Crear usuario'),
('eliminar_usuario','Eliminar usuarios'),
('crear_usuario','Crear usuario');

-- SUPERUSUARIO: acceso total
INSERT INTO roles_permissions (id_rol, id_permission)
SELECT 1, id_permission FROM permissions;

INSERT INTO roles_permissions (id_rol, id_permission) VALUES (1, 16);
INSERT INTO roles_permissions (id_rol, id_permission) VALUES (1, 17);
INSERT INTO roles_permissions (id_rol, id_permission) VALUES (1, 18);
INSERT INTO roles_permissions (id_rol, id_permission) VALUES (1, 19);
INSERT INTO roles_permissions (id_rol, id_permission) VALUES (1, 20);
INSERT INTO roles_permissions (id_rol, id_permission) VALUES (1, 21);

-- ADMINISTRADOR
INSERT INTO roles_permissions (id_rol, id_permission)
SELECT 3, id_permission FROM permissions
WHERE key IN (
    'ver_dashboard',
    'ver_inmuebles',
    'ver_reservas', 'crear_reserva', 'editar_reserva', 'eliminar_reserva',
    'ver_reportes', 'ver_caja', 'ver_propietarios', 'ver_ingresos', 'ver_egresos',
    'ver_disponibilidad', 'ver_huespedes', 'ver_usuarios'
);

-- PROPIETARIO
INSERT INTO roles_permissions (id_rol, id_permission)
SELECT 4, id_permission FROM permissions
WHERE key IN (
    'ver_dashboard',
    'ver_inmuebles',
    'ver_reservas',
    'ver_reportes'
);

ALTER TABLE inmuebles add column edificio VARCHAR(100);
ALTER TABLE inmuebles add column comision VARCHAR(10);
ALTER TABLE inmuebles add column precio_limpieza VARCHAR(10);
ALTER TABLE inmuebles add column apartamento VARCHAR(10);
ALTER TABLE inmuebles add column id_prod_sigo VARCHAR(10);
ALTER TABLE inmuebles add column capacidad_maxima INTEGER;
ALTER TABLE inmuebles add column nro_habitaciones INTEGER;
ALTER TABLE inmuebles add column nro_bahnos INTEGER;
ALTER TABLE inmuebles add column cocina BOOLEAN;



ALTER TABLE reservas ADD COLUMN codigo_reserva VARCHAR(20);
ALTER TABLE reservas ADD COLUMN precio_total NUMERIC(10,2) DEFAULT 0;
ALTER TABLE reservas ADD COLUMN observaciones TEXT;
ALTER TABLE reservas ADD COLUMN numero_huespedes INTEGER;



ALTER TABLE huespedes ADD COLUMN apellido VARCHAR(100);
ALTER TABLE huespedes ADD COLUMN email VARCHAR(255);
ALTER TABLE huespedes ADD COLUMN fecha_nacimiento DATE;
ALTER TABLE huespedes ADD COLUMN documento_tipo VARCHAR(50);
ALTER TABLE huespedes ADD COLUMN documento_numero VARCHAR(50);


ALTER TABLE reservas 
ADD COLUMN plataforma_origen VARCHAR(20) DEFAULT 'directa';

ALTER TABLE movimientos 
ADD COLUMN plataforma_origen VARCHAR(20) DEFAULT 'directa';




DO $$ 
BEGIN 
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'reservas' 
        AND column_name = 'plataforma_origen'
    ) THEN
        ALTER TABLE reservas 
        ADD COLUMN plataforma_origen VARCHAR(20) 
        DEFAULT 'directa' 
        CHECK (plataforma_origen IN ('airbnb', 'booking', 'pagina_web', 'directa'));
        
        -- Establecer valor por defecto en registros existentes
        UPDATE reservas SET plataforma_origen = 'directa' WHERE plataforma_origen IS NULL;
        
        -- Hacer la columna NOT NULL después de establecer valores por defecto
        ALTER TABLE reservas ALTER COLUMN plataforma_origen SET NOT NULL;
        
        RAISE NOTICE 'Columna plataforma_origen agregada a tabla reservas';
    ELSE
        RAISE NOTICE 'Columna plataforma_origen ya existe en tabla reservas';
    END IF;
END $$;

-- 2. AGREGAR COLUMNA plataforma_origen A LA TABLA movimientos
-- ===============================================================================

-- Verificar si la columna ya existe antes de agregarla
DO $$ 
BEGIN 
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'movimientos' 
        AND column_name = 'plataforma_origen'
    ) THEN
        ALTER TABLE movimientos 
        ADD COLUMN plataforma_origen VARCHAR(20) 
        NULL
        CHECK (plataforma_origen IN ('airbnb', 'booking', 'pagina_web', 'directa'));
        
        RAISE NOTICE 'Columna plataforma_origen agregada a tabla movimientos';
    ELSE
        RAISE NOTICE 'Columna plataforma_origen ya existe en tabla movimientos';
    END IF;
END $$;

-- 3. CREAR ÍNDICES PARA OPTIMIZAR CONSULTAS
-- ===============================================================================

-- Índice para reservas por plataforma de origen
CREATE INDEX IF NOT EXISTS idx_reservas_plataforma_origen 
ON reservas(plataforma_origen);

-- Índice para movimientos por plataforma de origen
CREATE INDEX IF NOT EXISTS idx_movimientos_plataforma_origen 
ON movimientos(plataforma_origen);

-- Índice compuesto para movimientos por fecha y plataforma (para filtros)
CREATE INDEX IF NOT EXISTS idx_movimientos_fecha_plataforma 
ON movimientos(fecha, plataforma_origen);

-- Índice compuesto para movimientos por empresa y plataforma (para reportes)
CREATE INDEX IF NOT EXISTS idx_movimientos_empresa_plataforma 
ON movimientos(id_empresa, plataforma_origen);

-- 4. FUNCIÓN PARA VALIDAR PLATAFORMA EN MOVIMIENTOS
-- ===============================================================================

-- Crear función para validar que plataforma_origen solo se use en ingresos de reserva
CREATE OR REPLACE FUNCTION validar_plataforma_movimiento()
RETURNS TRIGGER AS $$
BEGIN
    -- Solo permitir plataforma_origen en movimientos de tipo 'ingreso' con concepto 'reserva'
    IF NEW.plataforma_origen IS NOT NULL THEN
        IF NEW.tipo != 'ingreso' OR NEW.concepto != 'reserva' THEN
            RAISE EXCEPTION 'La plataforma de origen solo es válida para movimientos de tipo "ingreso" con concepto "reserva"';
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 5. CREAR TRIGGER PARA VALIDAR PLATAFORMA EN MOVIMIENTOS
-- ===============================================================================

-- Eliminar trigger si existe
DROP TRIGGER IF EXISTS trg_validar_plataforma_movimiento ON movimientos;

-- Crear trigger para validar plataforma de origen
CREATE TRIGGER trg_validar_plataforma_movimiento
    BEFORE INSERT OR UPDATE ON movimientos
    FOR EACH ROW
    EXECUTE FUNCTION validar_plataforma_movimiento();

-- 6. FUNCIÓN PARA SINCRONIZAR PLATAFORMA ENTRE RESERVA Y MOVIMIENTO
-- ===============================================================================

-- Crear función para copiar plataforma_origen de reserva a movimiento automáticamente
CREATE OR REPLACE FUNCTION sincronizar_plataforma_reserva_movimiento()
RETURNS TRIGGER AS $$
DECLARE
    reserva_plataforma VARCHAR(20);
BEGIN
    -- Solo aplicar si es un movimiento de ingreso con concepto reserva y tiene id_reserva
    IF NEW.tipo = 'ingreso' AND NEW.concepto = 'reserva' AND NEW.id_reserva IS NOT NULL THEN
        -- Obtener plataforma_origen de la reserva
        SELECT plataforma_origen INTO reserva_plataforma 
        FROM reservas 
        WHERE id_reserva = NEW.id_reserva::integer;
        
        -- Si se encuentra la reserva y no se especificó plataforma, usar la de la reserva
        IF reserva_plataforma IS NOT NULL AND NEW.plataforma_origen IS NULL THEN
            NEW.plataforma_origen = reserva_plataforma;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 7. CREAR TRIGGER PARA SINCRONIZACIÓN AUTOMÁTICA
-- ===============================================================================

-- Eliminar trigger si existe
DROP TRIGGER IF EXISTS trg_sincronizar_plataforma ON movimientos;

-- Crear trigger para sincronización automática (se ejecuta antes del trigger de validación)
CREATE TRIGGER trg_sincronizar_plataforma
    BEFORE INSERT OR UPDATE ON movimientos
    FOR EACH ROW
    EXECUTE FUNCTION sincronizar_plataforma_reserva_movimiento();

-- 8. ACTUALIZAR MOVIMIENTOS EXISTENTES CON PLATAFORMA DE SUS RESERVAS
-- ===============================================================================

-- Actualizar movimientos existentes que tienen reserva asociada
UPDATE movimientos m
SET plataforma_origen = r.plataforma_origen
FROM reservas r
WHERE m.id_reserva = r.id_reserva::text
  AND m.tipo = 'ingreso'
  AND m.concepto = 'reserva'
  AND m.plataforma_origen IS NULL;

-- 9. DATOS DE PRUEBA (OPCIONAL)
-- ===============================================================================

-- Insertar datos de prueba solo si no existen reservas con plataformas específicas
DO $$
BEGIN
    -- Solo agregar datos de prueba si no hay reservas con plataformas diferentes a 'directa'
    IF NOT EXISTS (
        SELECT 1 FROM reservas 
        WHERE plataforma_origen != 'directa'
        LIMIT 1
    ) THEN
        -- Actualizar algunas reservas existentes con diferentes plataformas para prueba
        UPDATE reservas 
        SET plataforma_origen = 'airbnb' 
        WHERE id_reserva IN (
            SELECT id_reserva FROM reservas 
            ORDER BY created_at DESC 
            LIMIT 2
        );
        
        UPDATE reservas 
        SET plataforma_origen = 'booking' 
        WHERE id_reserva IN (
            SELECT id_reserva FROM reservas 
            WHERE plataforma_origen = 'directa'
            ORDER BY created_at DESC 
            LIMIT 1
        );
        
        RAISE NOTICE 'Datos de prueba de plataformas agregados a reservas existentes';
    ELSE
        RAISE NOTICE 'Ya existen reservas con diferentes plataformas, no se agregaron datos de prueba';
    END IF;
END $$;

-- 10. CONSULTAS DE VERIFICACIÓN
-- ===============================================================================

-- Verificar que las columnas se agregaron correctamente
SELECT 
    table_name,
    column_name,
    data_type,
    is_nullable,
    column_default
FROM information_schema.columns 
WHERE table_name IN ('reservas', 'movimientos')
  AND column_name = 'plataforma_origen'
ORDER BY table_name, ordinal_position;

-- Verificar que los índices se crearon
SELECT 
    schemaname,
    tablename,
    indexname,
    indexdef
FROM pg_indexes 
WHERE tablename IN ('reservas', 'movimientos')
  AND indexname LIKE '%plataforma%'
ORDER BY tablename, indexname;

-- Verificar que las funciones se crearon
SELECT 
    routine_name,
    routine_type
FROM information_schema.routines 
WHERE routine_name LIKE '%plataforma%'
ORDER BY routine_name;

-- Verificar que los triggers se crearon
SELECT 
    trigger_name,
    event_object_table,
    action_timing,
    event_manipulation
FROM information_schema.triggers 
WHERE trigger_name LIKE '%plataforma%'
ORDER BY event_object_table, trigger_name;

-- Contar reservas por plataforma
SELECT 
    plataforma_origen,
    COUNT(*) as cantidad_reservas
FROM reservas 
GROUP BY plataforma_origen
ORDER BY cantidad_reservas DESC;

-- Contar movimientos por plataforma
SELECT 
    plataforma_origen,
    COUNT(*) as cantidad_movimientos,
    SUM(CASE WHEN tipo = 'ingreso' THEN monto ELSE 0 END) as total_ingresos
FROM movimientos 
WHERE plataforma_origen IS NOT NULL
GROUP BY plataforma_origen
ORDER BY total_ingresos DESC;






CREATE TABLE IF NOT EXISTS pagos (
    id                  BIGSERIAL PRIMARY KEY,
    id_reserva          BIGINT NOT NULL,
    monto               DECIMAL(15,2) NOT NULL CHECK (monto > 0),
    fecha_pago          DATE NOT NULL DEFAULT CURRENT_DATE,
    metodo_pago         VARCHAR(20) NOT NULL CHECK (metodo_pago IN ('efectivo', 'transferencia', 'tarjeta', 'otro')),
    concepto            VARCHAR(255) NOT NULL DEFAULT 'Pago de reserva',
    descripcion         TEXT NULL,
    comprobante         VARCHAR(255) NULL,
    id_empresa          BIGINT NOT NULL,
    id_usuario_registro BIGINT NULL,
    fecha_creacion      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    fecha_actualizacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Constrainst de validación
    CONSTRAINT chk_pago_monto_positivo CHECK (monto > 0),
    CONSTRAINT chk_pago_metodo_valido CHECK (metodo_pago IN ('efectivo', 'transferencia', 'tarjeta', 'otro')),
    CONSTRAINT chk_pago_concepto_no_vacio CHECK (char_length(trim(concepto)) > 0)
);

-- Comentarios en la tabla
COMMENT ON TABLE pagos IS 'Tabla para almacenar los pagos realizados por los huéspedes para sus reservas';
COMMENT ON COLUMN pagos.id IS 'Identificador único del pago';
COMMENT ON COLUMN pagos.id_reserva IS 'ID de la reserva asociada al pago';
COMMENT ON COLUMN pagos.monto IS 'Monto del pago en pesos colombianos';
COMMENT ON COLUMN pagos.fecha_pago IS 'Fecha en que se realizó el pago (importante para reportes diarios)';
COMMENT ON COLUMN pagos.metodo_pago IS 'Método utilizado para el pago';
COMMENT ON COLUMN pagos.concepto IS 'Concepto o descripción corta del pago';
COMMENT ON COLUMN pagos.descripcion IS 'Descripción detallada del pago (opcional)';
COMMENT ON COLUMN pagos.comprobante IS 'Número de comprobante o referencia del pago';
COMMENT ON COLUMN pagos.id_empresa IS 'ID de la empresa a la que pertenece el pago';
COMMENT ON COLUMN pagos.id_usuario_registro IS 'ID del usuario que registró el pago';

-- Índices para optimizar consultas
CREATE INDEX IF NOT EXISTS idx_pagos_reserva ON pagos(id_reserva);
CREATE INDEX IF NOT EXISTS idx_pagos_empresa ON pagos(id_empresa);
CREATE INDEX IF NOT EXISTS idx_pagos_fecha ON pagos(fecha_pago);
CREATE INDEX IF NOT EXISTS idx_pagos_metodo ON pagos(metodo_pago);
CREATE INDEX IF NOT EXISTS idx_pagos_empresa_fecha ON pagos(id_empresa, fecha_pago);
CREATE INDEX IF NOT EXISTS idx_pagos_reserva_fecha ON pagos(id_reserva, fecha_pago);

-- Claves foráneas (ajustar según la estructura actual de las tablas)
-- NOTA: Verificar que estas tablas existan antes de crear las FK
ALTER TABLE pagos 
ADD CONSTRAINT fk_pagos_reserva 
FOREIGN KEY (id_reserva) REFERENCES reservas(id_reserva) ON DELETE CASCADE;

-- Si la tabla empresas existe
ALTER TABLE pagos 
ADD CONSTRAINT fk_pagos_empresa 
FOREIGN KEY (id_empresa) REFERENCES empresas(id) ON DELETE CASCADE;

-- Si la tabla users existe
ALTER TABLE pagos 
ADD CONSTRAINT fk_pagos_usuario 
FOREIGN KEY (id_usuario_registro) REFERENCES users(id) ON DELETE SET NULL;

-- ========================================================================
-- MODIFICACIONES A LA TABLA MOVIMIENTOS (OPCIONAL)
-- Para establecer relación entre pagos y movimientos
-- ========================================================================

-- Agregar campo para relacionar movimientos con pagos
ALTER TABLE movimientos 
ADD COLUMN IF NOT EXISTS id_pago BIGINT NULL;

-- Índice para el nuevo campo
CREATE INDEX IF NOT EXISTS idx_movimientos_pago ON movimientos(id_pago);

-- Clave foránea hacia pagos
ALTER TABLE movimientos 
ADD CONSTRAINT fk_movimientos_pago 
FOREIGN KEY (id_pago) REFERENCES pagos(id) ON DELETE SET NULL;

-- Comentario en el nuevo campo
COMMENT ON COLUMN movimientos.id_pago IS 'ID del pago que generó este movimiento (si aplica)';

-- ========================================================================
-- VISTA PARA RESUMEN DE PAGOS POR RESERVA
-- ========================================================================

CREATE OR REPLACE VIEW vista_resumen_pagos_reserva AS
SELECT 
    r.id_reserva as id_reserva,
    r.codigo_reserva,
    r.total_reserva,
    COALESCE(SUM(p.monto), 0) as total_pagado,
    (r.total_reserva - COALESCE(SUM(p.monto), 0)) as total_pendiente,
    COUNT(p.id) as cantidad_pagos,
    CASE 
        WHEN COALESCE(SUM(p.monto), 0) = 0 THEN 'sin_pagos'
        WHEN COALESCE(SUM(p.monto), 0) < r.total_reserva THEN 'parcial'
        WHEN COALESCE(SUM(p.monto), 0) = r.total_reserva THEN 'completo'
        ELSE 'excedido'
    END as estado_pago,
    CASE 
        WHEN r.total_reserva > 0 THEN 
            ROUND((COALESCE(SUM(p.monto), 0) / r.total_reserva) * 100, 2)
        ELSE 0 
    END as porcentaje_pagado,
    MAX(p.fecha_pago) as fecha_ultimo_pago,
    -- Subconsulta para obtener datos del último pago
    (SELECT monto FROM pagos WHERE id_reserva = r.id_reserva ORDER BY fecha_pago DESC, fecha_creacion DESC LIMIT 1) as monto_ultimo_pago,
    (SELECT metodo_pago FROM pagos WHERE id_reserva = r.id_reserva ORDER BY fecha_pago DESC, fecha_creacion DESC LIMIT 1) as metodo_ultimo_pago
FROM reservas r
LEFT JOIN pagos p ON r.id_reserva = p.id_reserva
GROUP BY r.id_reserva, r.codigo_reserva, r.total_reserva;

-- Comentario en la vista
COMMENT ON VIEW vista_resumen_pagos_reserva IS 'Vista que proporciona un resumen financiero completo de cada reserva';

-- ========================================================================
-- VISTA PARA REPORTES DIARIOS DE PAGOS
-- ========================================================================

CREATE OR REPLACE VIEW vista_pagos_diarios AS
SELECT 
    p.fecha_pago,
    p.id_empresa,
    COUNT(*) as cantidad_pagos,
    SUM(p.monto) as total_ingresos_pagos,
    AVG(p.monto) as promedio_pago,
    -- Desglose por método de pago
    COUNT(CASE WHEN p.metodo_pago = 'efectivo' THEN 1 END) as pagos_efectivo,
    SUM(CASE WHEN p.metodo_pago = 'efectivo' THEN p.monto ELSE 0 END) as total_efectivo,
    COUNT(CASE WHEN p.metodo_pago = 'transferencia' THEN 1 END) as pagos_transferencia,
    SUM(CASE WHEN p.metodo_pago = 'transferencia' THEN p.monto ELSE 0 END) as total_transferencia,
    COUNT(CASE WHEN p.metodo_pago = 'tarjeta' THEN 1 END) as pagos_tarjeta,
    SUM(CASE WHEN p.metodo_pago = 'tarjeta' THEN p.monto ELSE 0 END) as total_tarjeta,
    COUNT(CASE WHEN p.metodo_pago = 'otro' THEN 1 END) as pagos_otro,
    SUM(CASE WHEN p.metodo_pago = 'otro' THEN p.monto ELSE 0 END) as total_otro
FROM pagos p
GROUP BY p.fecha_pago, p.id_empresa
ORDER BY p.fecha_pago DESC, p.id_empresa;

-- Comentario en la vista
COMMENT ON VIEW vista_pagos_diarios IS 'Vista para generar reportes diarios de pagos con desglose por método de pago';

-- ========================================================================
-- FUNCIÓN PARA TRIGGER DE ACTUALIZACIÓN AUTOMÁTICA
-- ========================================================================

-- Función para actualizar fecha_actualizacion automáticamente
CREATE OR REPLACE FUNCTION actualizar_fecha_actualizacion()
RETURNS TRIGGER AS $$
BEGIN
    NEW.fecha_actualizacion = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para la tabla pagos
CREATE TRIGGER trigger_pagos_fecha_actualizacion
    BEFORE UPDATE ON pagos
    FOR EACH ROW
    EXECUTE FUNCTION actualizar_fecha_actualizacion();

-- ========================================================================
-- AGREGAR COLUMNA fecha_reporte A MOVIMIENTOS Y PAGOS
-- ========================================================================

-- Agregar fecha_reporte a movimientos
ALTER TABLE movimientos ADD COLUMN fecha_reporte DATE;
COMMENT ON COLUMN movimientos.fecha_reporte IS 'Fecha de reporte del movimiento, distinta a la fecha de creación o transacción';

-- Agregar fecha_reporte a pagos
ALTER TABLE pagos ADD COLUMN fecha_reporte DATE;
COMMENT ON COLUMN pagos.fecha_reporte IS 'Fecha de reporte del pago, distinta a la fecha de creación o transacción';

-- Crear índices para fecha_reporte
CREATE INDEX IF NOT EXISTS idx_movimientos_fecha_reporte ON movimientos(fecha_reporte);
CREATE INDEX IF NOT EXISTS idx_pagos_fecha_reporte ON pagos(fecha_reporte);


ALTER TABLE inmuebles ALTER COLUMN comision TYPE DECIMAL(10,2) USING NULLIF(comision, '')::numeric;



INSERT INTO roles_permissions (id_rol, id_permission)
SELECT 2, id_permission FROM permissions
WHERE key IN (
    'ver_dashboard',
    'ver_inmuebles', 'crear_inmueble', 'editar_inmueble', 'eliminar_inmueble',
    'ver_reservas', 'crear_reserva', 'editar_reserva', 'eliminar_reserva',
    'ver_reportes', 'ver_caja', 'ver_propietarios', 'ver_ingresos', 'ver_egresos',
    'ver_disponibilidad', 'ver_huespedes', 'ver_usuarios', 'crear_usuario', 'crear_usuarios' 
);

ALTER TABLE inmuebles ADD COLUMN ciudad VARCHAR(60) DEFAULT 'Bucaramanga';


-- 1. Aumentar el límite de apellido a 100 caracteres (antes 20)
ALTER TABLE usuarios ALTER COLUMN apellido TYPE VARCHAR(120);

-- 2. Aumentar el límite de cedula a 50 caracteres (antes 20)
ALTER TABLE usuarios ALTER COLUMN cedula TYPE VARCHAR(40);

-- 3. Aumentar el límite de username a 100 caracteres (antes 20)
ALTER TABLE usuarios ALTER COLUMN username TYPE VARCHAR(150);